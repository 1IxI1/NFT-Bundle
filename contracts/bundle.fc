{-
  TON NFT Bundle Contract
  A contract that owns several NFT Items, allowing you to 
  transfer them and manage them as a package.

  With add-on for acting with ".ton" and similar
  contracts https://github.com/ton-blockchain/dns-contract.
-}

#include "stdlib.fc";
#include "messages.fc";
#include "common.fc";
#include "reserve.fc";

const int reward = 360000000; ;; 0.36 TON
const int renew_amonut = 5000000; ;; 0.005 TON

const int touch_base_fee = 9000000; ;; 0.009 TON
const int touch_one_fee = 3900000; ;; 0.005 TON

{- storage scheme:
  actions#_ (HashmapE 48 MessageAny) = Actions;

  storage#_ owner:MsgAddress scheduled_actions:Actions = Storage;
-}

;; owner, scheduled_actions
(slice, cell) load_data() impure inline {
    slice ds = get_data().begin_parse();
    return (ds~load_msg_addr(),
            ds~load_dict());
}

() save_data(slice owner, cell scheduled_actions) impure inline {
    var new_data = begin_cell().store_slice(owner)
                               .store_dict(scheduled_actions)
                    .end_cell();
    set_data(new_data);
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    ;; accept empty messages as deploy
    if ( in_msg_body.slice_empty?() ) { return (); }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);

    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }

    slice sender_address = cs~load_msg_addr();

    cs~load_msg_addr(); ;; skip dst
    cs~load_grams(); ;; skip value
    cs~skip_bits(1); ;; skip extracurrency collection
    cs~load_grams(); ;; skip ihr_fee
    int fwd_fee = cs~load_grams();

    (slice owner, cell scheduled_actions) = load_data();

    int op = in_msg_body~load_op();
    int query_id = in_msg_body~load_query_id();

    ;; transfer#5fcc3d14 query_id:uint64 new_owner:MsgAddress response_destination:MsgAddress
    ;;                   custom_payload:(Maybe ^Cell) forward_amount:(VarUInteger 16)
    ;;                   forward_payload:(Either Cell ^Cell) = InternalMsgBody;
    if (op == op::transfer) {
        throw_unless(errors::unauthorized, equal_slices(sender_address, owner));
        slice new_owner = transfer_ownership(my_balance, owner, in_msg_body, query_id, fwd_fee);
        save_data(new_owner, scheduled_actions);
        return ();
    }

    ;; send#2ecd9aca query_id:uint64 actions:Actions = InternalMsgBody;
    if (op == op::send) {
        ;; will just send many messages as a highload wallet
        throw_unless(errors::unauthorized, equal_slices(sender_address, owner));
        cell actions = in_msg_body~load_dict();
        do {
            var (_, slice action, int succ?) = actions~udict::delete_get_min(48);
            if (succ?) {
                send_raw_message(action~load_ref(), mode::PAY_FEES_SEPARATELY);
            }
        } until (~ succ?);
        raw_reserve(min_balance, reserve::this_amount);
        in_msg_body.end_parse();
        return ();
    }

    ;; schedule_actions#460da638 query_id:uint64 actions:Actions = InternalMsgBody;
    if (op == op::schedule_actions) {
        throw_unless(errors::unauthorized, equal_slices(sender_address, owner));
        cell actions = in_msg_body~load_dict();
        cell _actions = actions;

        ifnot ( cell_null?(_actions) ) {
            do {
                var (_, slice action, int succ?) = _actions~udict::delete_get_min(48);
                if (succ?) {
                    action = action~load_ref().begin_parse();
                    action~skip_bits(6 + 267); ;; msg flag & destination
                    int value = action~load_coins();
                    throw_unless(errors::incorrect_value, value == renew_amonut);
                }
            } until (~ succ?);
        }
        save_data(owner, actions);
        in_msg_body.end_parse();
        return ();
    }

    ;; touch#11111111 query_id:uint64 ensuring_key:(Maybe uint48) = InternalMsgBody;
    if (op == op::touch) {
        ;; this opcode will search through scheduled actions dictionary
        ;; for records with expired timers (key:uint48 < now).
        ;; for ex. we have 101, 102 .. 110 - total 10 actions
        ;; and now() is 105.
        ;; on call, it will send messages which are stored
        ;; under keys 101, 102, 103, 104, 105.
        ;; and will leave keys 106, 107, 108, 109, 110 for the future touches.
        ;; the toucher of the method (sender, anyone)
        ;; will get reward for each action he triggered.
        ;; so in example he will get reward*5.
        ;; user pays computation fees and his (for reward) fwd fee,
        ;; contract pays touch amounts (0.005) and fwd fees for them.
        throw_if(errors::no_actions, cell_null?(scheduled_actions));

        ;; `ensuring_key` works like `seqno`.
        ;; contract will check that the key was not triggered before.
        ;; to prevent decreasing desirable reward for toucher if someone has frontrun him.
        int has_ensuring_key? = in_msg_body~load_int(1);
        if (has_ensuring_key?) { 
            int ensuring_key = in_msg_body~load_uint(48);
            var (_, f?) = scheduled_actions.udict_get?(48, ensuring_key);
            throw_unless(errors::expired, f?);
        }
        ;; ensure msg has no more bits -
        ;; and sender does exactly what he want to do
        in_msg_body.end_parse();

        var (last_index, last_action, succ?) = scheduled_actions.udict_get_preveq?(48, now());
        throw_unless(errors::early_touch, succ?);
        int triggered_count = 0;

        ;; searching backwards for expired actions and sending them
        while (succ?) {
            ;; deleting last found action
            scheduled_actions~udict_delete?(48, last_index);
            send_raw_message(last_action~load_ref(), mode::PAY_FEES_SEPARATELY);
            triggered_count += 1;
            ;; going back in time
            (last_index, last_action, succ?) = scheduled_actions.udict_get_prev?(48, last_index);
        }

        ;; we can't use here raw_reserve
        ;; because message should bounce back to user on failure.
        int balance_before_msg = my_balance - msg_value;
        throw_unless(errors::not_enough_balance,
                     balance_before_msg >= min_balance +
                                   ;; renew_amount + fwd fee for every domain action
                                   ;; + rewards summarize for every triggered message.
                                   (renew_amonut + fwd_fee + reward) * triggered_count);

        send_msg(sender_address, reward * triggered_count, op::reward, query_id,
                 null(), mode::CARRY_REMAINING_GAS);

        save_data(owner, scheduled_actions);
        return ();
    }

    ;; get_static_data#2fcb26a2 query_id:uint64 = InternalMsgBody;
    if (op == op::get_static_data) {
        send_msg(sender_address, 0, op::report_static_data, query_id,
                 begin_cell().store_uint(0, 256)
                             .store_uint(0, 2), ;; null address
                 mode::CARRY_REMAINING_GAS);
        return ();
    }

    throw(errors::unknown_op);
}

cell get_scheduled_actions() method_id {
    var (owner, scheduled_actions) = load_data();
    return scheduled_actions;
}

(int, int) get_touch_reward_and_fee() method_id {
    var (owner, scheduled_actions) = load_data();
    var (last_index, last_action, succ?) = scheduled_actions.udict_get_preveq?(48, now());
    ifnot (succ?) {
        return (0, 0);
    }
    int ready = 0;
    while (succ?) {
        ready += 1;
        (last_index, last_action, succ?) = scheduled_actions.udict_get_prev?(48, last_index);
    }
    return (reward * ready, touch_base_fee + touch_one_fee * (ready - 1));
}

(int, int, slice, slice, cell) get_nft_data() method_id {
    var (owner, scheduled_actions) = load_data();
    return (true, 0, null(), owner, null());
}

int get_reward() method_id {
    return reward;
}
