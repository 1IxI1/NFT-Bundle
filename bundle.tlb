bit$_ (## 1) = Bit;
bool_false$0 = Bool;
bool_true$1 = Bool;

left$0 {X:Type} {Y:Type} value:X = Either X Y;
right$1 {X:Type} {Y:Type} value:Y = Either X Y;

//

hm_edge#_ {n:#} {X:Type} {l:#} {m:#} label:(HmLabel ~l n)
          {n = (~m) + l} node:(HashmapNode m X) = Hashmap n X;

hmn_leaf#_ {X:Type} value:X = HashmapNode 0 X;
hmn_fork#_ {n:#} {X:Type} left:^(Hashmap n X)
           right:^(Hashmap n X) = HashmapNode (n + 1) X;

hml_short$0 {m:#} {n:#} len:(Unary ~n) {n <= m} s:(n * Bit) = HmLabel ~n m;
hml_long$10 {m:#} n:(#<= m) s:(n * Bit) = HmLabel ~n m;
hml_same$11 {m:#} v:Bit n:(#<= m) = HmLabel ~n m;

unary_zero$0 = Unary ~0;
unary_succ$1 {n:#} x:(Unary ~n) = Unary ~(n + 1);

hme_empty$0 {n:#} {X:Type} = HashmapE n X;
hme_root$1 {n:#} {X:Type} root:^(Hashmap n X) = HashmapE n X;

//

nothing$0 {X:Type} = Maybe X;
just$1 {X:Type} value:X = Maybe X;

anycast_info$_ depth:(#<= 30) { depth >= 1 }
   rewrite_pfx:(bits depth) = Anycast;

addr_std$10 anycast:(Maybe Anycast)
   workchain_id:int8 address:bits256  = MsgAddressInt;
_ _:MsgAddressInt = MsgAddress;

//

var_uint$_ {n:#} len:(#< n) value:(uint (len * 8))
         = VarUInteger n;
var_int$_ {n:#} len:(#< n) value:(int (len * 8))
        = VarInteger n;
nanograms$_ amount:(VarUInteger 16) = Grams;

_ grams:Grams = Coins;

//

extra_currencies$_ dict:(HashmapE 32 (VarUInteger 32))
                 = ExtraCurrencyCollection;
currencies$_ grams:Grams other:ExtraCurrencyCollection
           = CurrencyCollection;

//

tick_tock$_ tick:Bool tock:Bool = TickTock;

_ split_depth:(Maybe (## 5)) special:(Maybe TickTock)
  code:(Maybe ^Cell) data:(Maybe ^Cell)
  library:(Maybe ^Cell) = StateInit;

int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
  src:MsgAddressInt dest:MsgAddressInt
  value:CurrencyCollection ihr_fee:Grams fwd_fee:Grams
  created_lt:uint64 created_at:uint32 = CommonMsgInfo;

message$_ {X:Type} info:CommonMsgInfo
  init:(Maybe (Either StateInit ^StateInit))
  body:(Either X ^X) = Message X;

_ (Message Any) = MessageAny;

//

// DICTREMMIN gives only slice.
// storing message as a ref for economy proposes in the contract.
actions#_ (HashmapE 48 ^MessageAny) = Actions;

storage#_ owner:MsgAddress scheduled_actions:Actions = Storage;

// schedule_actions, transfer, send

schedule_actions#460da638 query_id:uint64 actions:Actions = InternalMsgBody;
send#2ecd9aca query_id:uint64 actions:Actions = InternalMsgBody;

transfer#5fcc3d14 query_id:uint64 new_owner:MsgAddress response_destination:MsgAddress
                  custom_payload:(Maybe ^Cell) forward_amount:(VarUInteger 16)
                  forward_payload:(Either Cell ^Cell) = InternalMsgBody;

// `ensuring_key` works like `seqno`.
// contract will check that the key was not triggered before.
// to prevent decreasing desirable reward for toucher if someone has frontrun him.
touch#11111111 query_id:uint64 ensuring_key:(Maybe uint48) = InternalMsgBody;
